# services.traefik.enable = true;
{
  config,
  lib,
  pkgs,
  flake,
  ...
}: let
  cfg =
    config.services.traefik
    // {
      inherit (config.networking) hostName;
      inherit (flake.networking) ca domainName records;
      cert = "${cfg.dataDir}/cert"; # dir for self-signed certificates
      metricsPort = 81;
    };

  inherit (lib) genAttrs mapAttrs mkIf mkOption subtractLists types;
  inherit (cfg.lib) mkHostNames mkMiddleware mkRouter mkService;
in {
  # Import all *.nix files in this directory
  imports = flake.lib.ls ./.;

  options.services.traefik = {
    # Shortcut for adding reverse proxies
    proxy = mkOption {
      type = with types; anything;
      default = {};
    };

    # All hostHames Traefik detects
    hostNames = mkOption {
      type = with types; listOf str;
      default = [];
    };

    # OpenSSL certificates are created from this
    internalHostNames = mkOption {
      type = with types; listOf str;
      default = [];
    };

    # Add additional hostNames to treat as internal
    extraInternalHostNames = mkOption {
      type = with types; listOf str;
      default = [];
    };

    # LetsEncrypt certificates are created from this
    externalHostNames = mkOption {
      type = with types; listOf str;
      default = [];
    };

    # BlockyDNS records mappings are created from this
    privateHostNames = mkOption {
      type = with types; listOf str;
      default = [];
    };

    # CloudFlare DNS records are created from this
    publicHostNames = mkOption {
      type = with types; listOf str;
      default = [];
    };

    # Collection of hostName to IP addresses from this Traefik configuration
    records = mkOption {
      type = with types; anything;
      default = {};
    };
  };

  config = mkIf cfg.enable {
    # Configure traefik service
    services.traefik = {
      # Combinations:
      # --------------------------------
      # External / Public:  public service on Internet, using CloudFlare & Let's Encrypt
      # External / Private: personal service on LAN/VPN, using CloudFlare & Let's Encrypt
      # Internal / Private: personal service on LAN/VPN, using Blocky & OpenSSL (most common)
      # Internal / Public: invalid combination

      # All hostHames Traefik detects
      hostNames = mkHostNames {};

      # List of private hostNames using local DNS which will have certificates generated by custom CA
      # - OpenSSL certificates are created from this
      internalHostNames = mkHostNames {external = false;} ++ cfg.extraInternalHostNames;

      # List of external hostNames that need certificates generated externally by Let's Encrypt
      # - LetsEncrypt certificates are created from this
      externalHostNames = subtractLists cfg.extraInternalHostNames (mkHostNames {external = true;});

      # List of private hostNames using local DNS which will have certificates generated by custom CA or Let's Encrypt
      # - BlockyDNS records mappings are created from this
      privateHostNames = mkHostNames {public = false;};

      # List of public hostNames that require external DNS records in CloudFlare and certificates by Let's Encrypt
      # - CloudFlare DNS records are created from this
      publicHostNames = mkHostNames {public = true;};

      # Collection of hostName to IP addresses from this Traefik configuration
      records = genAttrs cfg.privateHostNames (_: cfg.records.${cfg.hostName} or "127.0.0.1");
      # --------------------------------

      # v3.0.2
      package = pkgs.traefik;

      # Required so traefik is permitted to watch docker events
      group = "docker";

      # Static configuration
      staticConfigOptions = {
        api.insecure = false;
        api.dashboard = true;

        # Allow backend services to have self-signed certs
        serversTransport.insecureSkipVerify = true;

        # Watch docker events and discover services
        providers.docker = {
          endpoint = "unix:///var/run/docker.sock";
          exposedByDefault = false;
        };

        # Listen on port 80 and redirect to port 443
        entryPoints = {
          # Run everything on 443
          websecure.address = ":443";

          # Redirect http to https
          web.address = ":80";
          web.http.redirections.entrypoint = {
            to = "websecure";
            scheme = "https";
          };

          # Metrics for prometheus
          metrics.address = ":${toString cfg.metricsPort}";
        };

        metrics.addInternals = true;

        metrics.prometheus = {
          entryPoint = "metrics";
          buckets = ["0.100000" "0.300000" "1.200000" "5.000000"];
          addServicesLabels = true;
          addEntryPointsLabels = true;
        };

        # Let's Encrypt will check CloudFlare's DNS
        certificatesResolvers.resolver-dns.acme = {
          dnsChallenge.provider = "cloudflare";
          storage = "${cfg.dataDir}/cert.json";
          email = "dns@${cfg.domainName}";
        };

        global = {
          checkNewVersion = false;
          sendAnonymousUsage = false;
        };
      };

      # Dynamic configuration
      dynamicConfigOptions = {
        http = {
          # Generate traefik middlewares from configuration proxy
          middlewares =
            (
              mapAttrs mkMiddleware cfg.proxy
              # Include a couple extra middlewares often used
            )
            // {
              # Basic Authentication is available. User/passwords are encrypted by agenix.
              # login.basicAuth.usersFile = secrets.basic-auth.path;

              # Whitelist local network and VPN addresses
              # local.ipWhiteList.sourceRange = [
              local.ipAllowList.sourceRange = [
                "127.0.0.1/32" # local host
                "192.168.0.0/16" # local network
                "10.0.0.0/8" # local network
                "172.16.0.0/12" # docker network
                "100.64.0.0/10" # vpn network
              ];
            };

          # Generate traefik services from configuration proxy
          services =
            (
              mapAttrs mkService cfg.proxy
              # Avoid a config error ensuring at least one service defined
            )
            // {"noop" = {};};

          # Generate traefik routers from configuration proxy
          routers =
            (
              mapAttrs mkRouter cfg.proxy
              # Make available the traefik dashboard
            )
            // {
              traefik = {
                entrypoints = "websecure";
                tls = {};
                rule = "Host(`${cfg.hostName}`) || Host(`traefik.${cfg.hostName}`)";
                middlewares = "local";
                service = "api@internal";
              };
            };
        };

        # Add every module certificate into the default store
        tls.certificates =
          map (name: {
            certFile = "${cfg.cert}/${name}.crt";
            keyFile = "${cfg.cert}/key";
          })
          cfg.internalHostNames;

        # Also change the default certificate
        tls.stores.default.defaultCertificate = {
          certFile = "${cfg.cert}/${cfg.hostName}.crt";
          keyFile = "${cfg.cert}/key";
        };
      };
    };

    # Persist data after reboots
    persist.storage.directories = [cfg.dataDir];

    # Give traefik user permission to read secrets
    users.users.traefik.extraGroups = ["secrets"];

    # CloudFlare DNS API Token
    # https://dash.cloudflare.com/profile/api-tokens
    # CF_DNS_API_TOKEN=xxxxxx
    age.secrets.cloudflare.rekeyFile = ./cloudflare.age;
    systemd.services.traefik.serviceConfig = {
      EnvironmentFile = [config.age.secrets.cloudflare.path];
    };

    # Self-signed certificates
    system.activationScripts.traefik.text = let
      inherit (builtins) concatStringsSep toString;
      inherit (lib) concatMapStrings imap1 unique;
      caKey = config.age.secrets.ca.path;

      # All IP addresses this host is reachable at
      addresses = concatStringsSep "\n" (
        imap1
        (i: x: "IP.${toString i} = ${x}")
        config.networking.addresses
      );

      # openssl config file for each hostName
      mkConfig = hostName:
        pkgs.writeTextFile {
          name = "openssl.cnf";
          text = ''
            [ req ]
            distinguished_name = req_distinguished_name
            req_extensions = v3_req

            [ req_distinguished_name ]
            commonName = ${hostName}

            [ v3_req ]
            basicConstraints = CA:FALSE
            keyUsage = nonRepudiation, digitalSignature, keyEncipherment
            subjectAltName = @alt_names

            [ alt_names ]
            DNS.1 = ${hostName}
            DNS.2 = *.${hostName}
            ${addresses}
          '';
        };

      # openssl commands for each hostName
      perHostName = hostName: let
        opensslConfig = mkConfig hostName;
      in
        # bash
        ''
          openssl req -new \
            -key ${cfg.cert}/key \
            -config ${opensslConfig} \
            -extensions v3_req \
            -subj "/CN=${hostName}" \
            -out ${cfg.cert}/csr

          openssl x509 -req \
            -days 365 \
            -in ${cfg.cert}/csr \
            -extfile ${opensslConfig} \
            -extensions v3_req \
            -CA ${cfg.ca} \
            -CAkey ${caKey} \
            -CAserial ${cfg.cert}/serial \
            -out ${cfg.cert}/${hostName}.crt

          rm -f ${cfg.cert}/csr
        '';
    in
      # Create self-signed certificates for each hostName, signed by custom CA
      # bash
      ''
        PATH="$PATH:${pkgs.openssl}/bin"
        mkdir -p ${cfg.cert}
        chmod 775 ${cfg.cert}
        [[ -e ${cfg.cert}/key ]] || openssl genrsa -out ${cfg.cert}/key 4096
        [[ -e ${cfg.cert}/serial ]] || echo 01 > ${cfg.cert}/serial
        if [[ -f ${caKey} ]]; then
          ${concatMapStrings perHostName (unique cfg.internalHostNames)}
        fi
        chown -R traefik:traefik ${cfg.cert}
      '';

    # Configure prometheus to check traefik's metrics
    services.prometheus = {
      scrapeConfigs = [
        {
          job_name = "traefik";
          static_configs = [
            {targets = ["127.0.0.1:${toString cfg.metricsPort}"];}
          ];
        }
      ];
    };

    # Open up the firewall for http and https
    networking.firewall.allowedTCPPorts = [80 443];
  };
}
