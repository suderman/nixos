#!/usr/bin/env bash
# This script was generated by bashly 1.1.3 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
nixos_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos - nixos-cli application\n"
    echo

  else
    printf "nixos - nixos-cli application\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos COMMAND\n"
  printf "  nixos [COMMAND] --help | -h\n"
  printf "  nixos --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Deploy Commands:")"
  printf "  %s   Deploy flake to local or remote systems\n" "$(green "deploy")         "
  printf "  %s   Rollback to the previous generation\n" "$(green "rollback")       "
  printf "  %s   Install a NixOS configuration on fresh hardware\n" "$(green "bootstrap")      "
  echo
  printf "%s\n" "$(bold "Secrets Commands:")"
  printf "  %s   Edit or add secrets to secrets/files\n" "$(green "secrets")        "
  printf "  %s   Rekey secrets with secrets/keys\n" "$(green "rekey")          "
  printf "  %s   Scan a host for public keys and add to secrets/keys\n" "$(green "keyscan")        "
  echo
  printf "%s\n" "$(bold "Utility Commands:")"
  printf "  %s   Start a repl for this flake\n" "$(green "repl")           "
  printf "  %s   Shortcut for nix build piped to cachix\n" "$(green "cache")          "
  printf "  %s   Shortcut to generate this CLI from source\n" "$(green "bashly-generate")"
  printf "  %s   Generate bash completions\n" "$(green "completions")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
nixos_deploy_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos deploy\n"
    echo

    printf "  Deploy flake to local or remote systems\n  Wrapper for nixos-rebuild\n"
    echo

  else
    printf "nixos deploy - Deploy flake to local or remote systems\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos deploy [TARGET] [OPTIONS]\n"
  printf "  nixos deploy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--switch, -s")"
    printf "    Make this config the default boot option, and activate (default)\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--boot, -b")"
    printf "    Make this config the default boot option, but don't activate\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--test, -t")"
    printf "    Activate this config, but don't make it the default boot option\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TARGET")"
    printf "    Name of target host (default: this machine)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos deploy\n"
    printf "  nixos deploy foo --boot\n"
    echo

  fi
}

# :command.usage
nixos_rollback_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos rollback\n"
    echo

    printf "  Rollback to the previous generation\n  Wrapper for nixos-rebuild --rollback switch\n"
    echo

  else
    printf "nixos rollback - Rollback to the previous generation\n"
    echo

  fi

  printf "Alias: rb\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos rollback [TARGET] [OPTIONS]\n"
  printf "  nixos rollback --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--switch, -s")"
    printf "    Rollback the previous boot option and activate previous config (default)\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--boot, -b")"
    printf "    Rollback the previous boot option, but don't activate\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--test, -t")"
    printf "    Rollback to the previous config, but don't make it the default boot option\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TARGET")"
    printf "    Name of target host (default: this machine)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos rollback\n"
    printf "  nixos rollback foo --boot\n"
    echo

  fi
}

# :command.usage
nixos_bootstrap_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos bootstrap - Install a NixOS configuration on fresh hardware\n"
    echo

  else
    printf "nixos bootstrap - Install a NixOS configuration on fresh hardware\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos bootstrap [OPTIONS]\n"
  printf "  nixos bootstrap --help\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--config, -c CONFIG")"
    printf "    name of NixOS configuration\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--hardware, -h HARDWARE")"
    printf "    direct, linode\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--firmware, -f FIRMWARE")"
    printf "    uefi, bios\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--swap, -s SWAP")"
    printf "    min, max, or any number of GB for swap (default: max)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help")"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos bootstrap --hardware linode\n"
    printf "  nixos bootstrap --firmware uefi --swap min\n"
    printf "  nixos bootstrap --firmware bios --swap 8\n"
    printf "  nixos bootstrap --config sol\n"
    echo

  fi
}

# :command.usage
nixos_secrets_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos secrets\n"
    echo

    printf "  Edit or add secrets to secrets/files\n  Wrapper for agenix --edit\n"
    echo

  else
    printf "nixos secrets - Edit or add secrets to secrets/files\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos secrets [SECRET] [OPTIONS]\n"
  printf "  nixos secrets --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--commit, -c")"
    printf "    Automatically commit changes to git\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "SECRET")"
    printf "    name of secret (leave empty to choose from list)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos secrets\n"
    printf "  nixos secrets foo\n"
    echo

  fi
}

# :command.usage
nixos_rekey_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos rekey\n"
    echo

    printf "  Rekey secrets with secrets/keys\n  Wrapper for agenix --rekey\n"
    echo

  else
    printf "nixos rekey - Rekey secrets with secrets/keys\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos rekey [OPTIONS]\n"
  printf "  nixos rekey --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--force, -f")"
    printf "    Force rekey even if no changes have been detected\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--commit, -c")"
    printf "    Automatically commit changes to git\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos rekey\n"
    printf "  nixos rekey --force\n"
    printf "  nixos rekey --commit\n"
    echo

  fi
}

# :command.usage
nixos_keyscan_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos keyscan\n"
    echo

    printf "  Scan a host for public keys and add to secrets/keys\n  Wrapper for ssh-keyscan\n"
    echo

  else
    printf "nixos keyscan - Scan a host for public keys and add to secrets/keys\n"
    echo

  fi

  printf "Alias: k\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos keyscan IP [HOSTNAME] [OPTIONS]\n"
  printf "  nixos keyscan --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(magenta "--force, -f")"
    printf "    Force rekey after keyscan\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--add, -a")"
    printf "    Add extra host key instead of replacing\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(magenta "--commit, -c")"
    printf "    Automatically commit changes to git\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IP")"
    printf "    IP address or hostname\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "HOSTNAME")"
    printf "    Name of host (default: first argument)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  nixos keyscan 192.168.1.10 myhost\n"
    printf "  nixos keyscan 192.168.1.10 myhost --force\n"
    printf "  nixos keyscan 192.168.1.10 myhost --add --commit\n"
    echo

  fi
}

# :command.usage
nixos_repl_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos repl - Start a repl for this flake\n"
    echo

  else
    printf "nixos repl - Start a repl for this flake\n"
    echo

  fi

  printf "Alias: rp\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos repl\n"
  printf "  nixos repl --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_cache_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos cache - Shortcut for nix build piped to cachix\n"
    echo

  else
    printf "nixos cache - Shortcut for nix build piped to cachix\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos cache\n"
  printf "  nixos cache --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_bashly_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos bashly-generate - Shortcut to generate this CLI from source\n"
    echo

  else
    printf "nixos bashly-generate - Shortcut to generate this CLI from source\n"
    echo

  fi

  printf "Alias: bg\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos bashly-generate\n"
  printf "  nixos bashly-generate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
nixos_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "nixos completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(cli completions)\"\n"
    echo

  else
    printf "nixos completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  nixos completions\n"
  printf "  nixos completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/helpers.sh
#!/usr/bin/env bash

# True if command or file does exist
function has {
  if [[ -e "$1" ]]; then return 0; fi
  command -v "$1" >/dev/null 2>&1 && { return 0; }
  return 1
}

# True if command or file doesn't exist
function hasnt {
  if [[ -e "$1" ]]; then return 1; fi
  command -v "$1" >/dev/null 2>&1 && { return 1; }
  return 0
}

# True if variable is not empty
function defined {
  if [[ -z "$1" ]]; then return 1; fi

  return 0
}

# True if variable is empty
function empty {
  if [[ -z "$1" ]]; then return 0; fi
  return 1
}

# Echo information
function info {

  echo "$(green_bold "#") $(green "$*")"

}

# Echo warning
function warn {

  echo "$(red_bold "#") $(red "$*")"

}

# Return error
function error {

  warn "Error: ${*-exiting}" && exit 1
}

# Show arguments
function show {
  echo "$(magenta_bold ">") $(magenta "$*")";
}

# Echo task and execute command (unless --dry-run)
function task {

  show "${@}"
  eval "${@}" > /tmp/task
}

# Echo output from last task
function last {
  touch /tmp/task
  cat /tmp/task
}

# Echo URL, copy to clipboard, and open in browser
function url {

  has wl-copy && echo "$1" | wl-copy
  has xdg-open && xdg-open "$1"
  echo "$(magenta_bold ">") $(cyan_underlined "$1")"
}

# Pause script until input
function pause {
  include smenu
  [[ -n "$*" ]] && info "${*}"
  smenu -d -i "continue" -a e:7 i:2,br c:2,blr <<< "Press enter to continue ..."
}

# Echo but spaces replaced with newlines
function explode {
  echo "$@" | tr ' ' '\n'
}

# warn "Wanna go on?"
# if confirm; then
#   echo "You do! :)"
# else
#   echo "You don't :("
# fi
function confirm {
  [[ "$(ask "yes no")" == "yes" ]] && return 0 || return 1

}

# info "What is your name?"
# name="$(ask)"
# info "Which color?"
# color="$(ask "red green blue" "green")"
function ask {

  include smenu
  # Check for 1st arg or stdin
  local words="${1}"; [[ -p /dev/stdin ]] && words="$(cat -)"
  # Check for 2nd arg as search word
  local search="${2}"; [[ -n "$search" ]] && search="-s ${search}"

  # Check for 3rd arg as timer seconds
  local timer="${3}"; [[ -n "$timer" ]] && timer="-X ${timer}"

  # If any words, get choice from smenu
  if [[ -n "$words" && "$words" != "-" ]]; then
    smenu -c -a i:3,b c:3,br $search $timer <<< "$words"
  # Otherwise, prompt for input
  else
    local reply=""; while [[ -z "$reply" ]]; do
      read -p "$(blue_bold :) " -i "${2}" -e reply
    done; echo "$reply"
  fi
}

# info "Choose your disk"
# disk="$(ask_disk)"
function ask_disk {
  include smenu
  local disk="refresh"
  while [[ "$disk" = "refresh" ]]; do
    disk="$(smenu -c -q -n 20 -N -d \
      -I '/__/ /g' -E '/__/ /g' \
      -i ^nvme -i ^sd -i ^hd -i ^vd \
      -i refresh -i cancel \
      -a e:4 i:6,b c:6,br  \
      -1 '(refresh|cancel)' '3,b' \
      -s /refresh \
      <<< "$(ask_disk_menu)")"
  done
  [[ "$disk" != "cancel" ]] && echo "$disk" || return 1
}

function ask_disk_menu {
  include lsblk:util-linux
  local menu="$(lsblk -o NAME,FSTYPE,LABEL,FSAVAIL,FSUSE%,MOUNTPOINT)"
  menu="${menu}\n__\n"
  menu="${menu}refresh__ cancel__"
  echo "$menu"
}

# info "Enter your IP address"
# ip="$(ask_ip 192.168.0.2)"
function ask_ip {
  include smenu
  local ip="" last_ip="" ips="" search=""
  [[ -n "$1" ]] && ip="$1" || ip="$(ask - "192.168.")"
  while :; do
    last_ip="$ip"
    if $(ping -c1 -w1 $ip >/dev/null 2>&1); then
      echo "$ip"
      return 0
    else
      [[ -n "$ip" ]] && search="-s $ip" || search=""
      ips="$(echo "${ips} ${ip}" | tr ' ' '\n' | sort | uniq | xargs)"
      ip="$(smenu -m "Retrying IP address" -q -d -a i:3,b c:3,br $search -x 10 <<< "[new] $ips [cancel]" )"
      [[ "$ip" == "[cancel]" ]] && return 1
      [[ "$ip" == "[new]" ]] && ip="$(ask - "$last_ip")"
    fi
  done
}

# Install nixos dependencies if they don't exist
# If package name doesn't match command, append pkg after colon
# Example: include git awk:gawk smenu
function include {
  local arg cmd pkg
  for arg in "$@"; do
    if [[ $arg == *":"* ]]; then
      IFS=: read -r cmd pkg <<< "$arg"
    else
      cmd="$arg"
      pkg="$arg"
    fi
    if hasnt $cmd; then
      info "Installing $pkg"
      task nix-env -iA nixos.$pkg
    fi
  done
}

# smenu formatting
# ----------------
#
# [fb]/[bg],[blru]
#
# 0: black    1: red    2: green
# 3: yellow   4: blue   5: purple
# 6: aqua     7: white  8: gray
#

# [b]old b[l]inking [r]everse [u]nderline
#
# -N                   :: numbers added for selection
# -q                   :: hide scroll bar
# -N                   :: numbers added for selection
# -n 20                :: number of lines height
# -i '^[a-z].'         :: regex for what is selectable
# -1 '^[a-z].' '1/0,b' :: regex for formatting
# -m                   :: Message for title
# -d                   :: Clear menu after selection
# -W$'\n'              ::

# src/lib/send_completions.sh
send_completions() {
  echo $'# nixos completion                                         -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_nixos_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $'  '
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_nixos_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'download\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'linode\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'upload\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --password --user -h -p -u")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'d\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--force --help -f -h")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    \'u\'*)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --password --user -h -p -u")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=( "$REPLY" ); done < <( compgen -W "$(_nixos_completions_filter "--help --version -h -v d download l linode u upload")" -- "$cur" )'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'complete -F _nixos_completions nixos'
  echo $''
  echo $'# ex: filetype=sh'
}

# :command.command_functions
# :command.function
nixos_deploy_command() {
  # src/deploy_command.sh
  local dir="/etc/nixos"

  # List all NixOS configurations, skipping bootstrap
  function configurations {
    nix flake show --json $dir | jq -r '.nixosConfigurations | keys[] | select(. != "bootstrap")' | xargs
  }

  # Choose from list of configurations, including [all] to deploy to full list

  local targets="$(ask "$(configurations) [all]" "${args[target]-$(hostname)}")"
  [[ "$targets" == "[all]" ]] && targets="$(configurations)"

  # Default action is switch configuration, but boot and test are available
  local action="switch"
  if [[ "${args[--boot]}" == "1" ]]; then
    action="boot"
  elif [[ "${args[--test]}" == "1" ]]; then
    action="test"
  fi

  # nixos-rebuild on all selected targets
  for target in $targets; do
    if [[ "${target}" == "$(hostname)" ]]; then
      # https://github.com/NixOS/nixpkgs/issues/195777#issuecomment-1324378856
      task "sudo systemctl restart systemd-udev-trigger.service"

      task "sudo nixos-rebuild --flake ${dir}#${target} ${action}"
    else
      task "nixos-rebuild --build-host ${USER}@${target}.$(domainname) --target-host ${USER}@${target}.$(domainname) --flake ${dir}#${target} --use-remote-sudo ${action}"
    fi
  done

}

# :command.function
nixos_rollback_command() {
  # src/rollback_command.sh
  local dir="/etc/nixos"

  # List all NixOS configurations, skipping bootstrap
  function configurations {
    nix flake show --json $dir | jq -r '.nixosConfigurations | keys[] | select(. != "bootstrap")' | xargs
  }

  # Choose from list of configurations, including [all] to deploy to full list

  local targets="$(ask "$(configurations) [all]" "${args[target]-$(hostname)}")"
  [[ "$targets" == "[all]" ]] && targets="$(configurations)"

  # Default action is switch configuration, but boot and test are available
  local action="switch"
  if [[ "${args[--boot]}" == "1" ]]; then
    action="boot"
  elif [[ "${args[--test]}" == "1" ]]; then
    action="test"
  fi

  # nixos-rebuild on all selected targets
  for target in $targets; do
    task "nixos-rebuild --target-host root@${target}.$(domainname) --flake ${dir}#${target} --rollback ${action}"

  done

}

# :command.function
nixos_bootstrap_command() {
  # src/bootstrap_command.sh
  local iso="https://channels.nixos.org/nixos-23.11/latest-nixos-minimal-x86_64-linux.iso"
  local cli="https://github.com/suderman/nixos/raw/main/overlays/bin/nixos-cli/nixos"
  local dir="/etc/nixos" config hardware firmware swap default_swap

  function main {

    include git smenu awk:gawk sed:gnused linode-cli jq smenu

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃              Bootstrap NixOS              ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    if [[ "$(hostname)" == "nixos" ]]; then
      info "Installer ISO detected, launching Stage 1"
      stage1
    elif [[ "$(hostname)" == "bootstrap" ]]; then
      info "Bootstrap configuration detected, launching Stage 2"
      stage2
    else

      info "Choose NixOS configuration to install:"
      config="$(ask "$(configurations)" ${args[--config]})"
      echo

      info "Choose type of hardware:"
      hardware="$(ask "direct linode" ${args[--hardware]})"
      echo

      # Linode install must boot via bios
      if [[ "$hardware" == "linode" ]]; then
        firmware="bios"
        default_swap="min"

      # Direct install on physical hardware
      else

        info "Choose type of firmware:"
        firmware="$(ask "uefi bios" ${args[--firmware]})"
        default_swap="max"
        echo
      fi

      # Swap partition size
      info "Choose swap size (\"max\" required for hibernate):"
      swap="$(ask "[custom] min max ${args[--swap]}" ${args[--swap]-$default_swap})"
      [[ "$swap" == "[custom]" ]] && swap="$(ask - "2")"
      echo

      info "Review configuration"
      show config: $config
      show hardware: $hardware
      show firmware: $firmware
      show swap: $swap
      echo && pause

      if [[ $hardware == "linode" ]]; then
        info "Starting NixOS installation process on linode server"
        echo && hardware_linode
      else
        info "Starting NixOS installation process on direct hardware"
        echo && hardware_direct
      fi

    fi

  }

  # Wizard guiding installation directly on hardware (laptop, home server, etc)
  function hardware_direct {

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 1: Create NixOS installer            ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    echo && info "Create NixOS Installer (choose \"no\" to skip this step)"
    if confirm; then
      echo && info "Choose removable disk to write NixOS installer ISO"
      local disk="$(ask_disk)"
      if [[ -n "${disk}" && -e /dev/$disk ]]; then
        warn "Overwrite all data on ${disk} with NixOS installer?"
        if confirm; then
          info "Unmounting disk"
          for partition in "$(mount | awk '$1 ~ /^\/dev\/'$disk'/ {print $1}')"; do
            task sudo umount $partition
          done
          info "Erasing disk"
          task sudo parted -s /dev/$disk mklabel gpt
          info "Downloading ISO to disk"
          task "sudo bash -c 'curl -L $iso | dd bs=4M status=progress conv=fdatasync of=/dev/${disk}'"

          info "Finished. Remove NixOS installer disk from this computer."
        fi
      fi
    fi
    echo
    info "Insert NixOS installer disk into target computer. Then boot from the installer."
    pause && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 2: Install bootstrap configuration   ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    echo && info "Type the following to install NixOS:"
    local firmware_flag=""; [[ "$firmware" == "uefi" ]] || firmware_flag="-f $firmware"
    local swap_flag=""; [[ "$swap" == "max" ]] || swap_flag="-s $swap"
    line1="sudo -s"
    line2="bash <(curl -sL $cli) bootstrap $firmware_flag $swap_flag"
    show $line1
    show $line2
    echo "$line2" | wl-copy && echo

    info "After it's finished, remove the installer disk and reboot into NixOS."
    pause && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 3: Rekey secrets                     ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    echo && info "On the target computer, login as root. Password is also \"root\""
    show "bootstrap login: root"
    echo && info "Run the following command to discover the target's IP address:"
    show "ip -4 a | grep inet"
    echo && info "What is the IP address of the target computer?"
    local ip="$(ask_ip)"
    echo && info "Waiting to keyscan the target..."
    until ping -c1 $ip >/dev/null 2>&1; do sleep 5; done
    task "nixos keyscan $ip $config --add --commit"
    echo && info "Pushing secrets back to git"
    task "cd $dir && git push"

    sleep 5 && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 4: Switch configuration              ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    echo && info "On the target computer, run the following command:"
    show "nixos bootstrap -c $config" && echo
    info "After it's finished, the target computer will automatically reboot into the $config configuration."
    pause && info "Install complete!"

  }

  # Wizard guiding installation on linode virtual hardware
  function hardware_linode {

    if [[ ! -e ~/.config/linode-cli ]]; then
      error "Missing ~/.config/linode-cli configuration. Run linode-cli to login and setup token on this computer, then start again."
    fi

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 1: Provision server                  ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Choose linode from list
    echo && info "Choose which existing linode to prepare"
    local linode="$(ask "$(linode-cli linodes list --text --no-header | awk '{print $1"_"$2}')")"
    local id="$(echo "${linode%_*}")"
    echo
    [[ -z "$id" ]] && error "Missing linode ID"

    # Look up details about this linode
    info "Gathering details..."; echo
    local label="$(linode-cli linodes view $id --format label --no-header --text)"
    local linode_type=$(linode-cli linodes view $id --no-header --text --format type) # example: g6-standard-1
    local linode_size=$(linode-cli linodes type-view $linode_type --no-header --text --format disk) # example: 51200
    local installer_size=1024  # reserve 1GB for installer
    local nixos_size=$((linode_size - installer_size)) # nix uses remaining available disk
    local flags nixos_disk nixos_config installer_disk installer_config

    # Final warning
    warn "DANGER! Last chance to bail!"
    warn "Re-create all disks and configurations for linode $(magenta \"${label}\")?"
    confirm || return && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 2: Create disks & profiles           ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Power down
    echo && info "OK! Powering off linode. Please wait..."
    task linode-cli linodes shutdown $id
    wait_for_linode $id "offline" && echo

    # Delete all configurations
    info "Deleting any existing configurations"
    configs=($(linode-cli linodes configs-list $id --text | awk 'NR > 1 {print $1}'))
    for config_id in "${configs[@]}"; do
      task linode-cli linodes config-delete $id $config_id
      sleep 5
    done && echo

    # Delete all disks
    info "Deleting any existing disks"
    disks=($(linode-cli linodes disks-list $id --text | awk 'NR > 1 {print $1}'))
    for disk_id in "${disks[@]}"; do
      task linode-cli linodes disk-delete $id $disk_id
      while [ "$(linode-cli linodes disk-view $id $disk_id --text --no-header --format status 2>/dev/null)" == "deleting" ]; do
        sleep 5
      done
    done && echo

    # Shared flags
    flags="--text --no-header"

    info "Creating INSTALLER disk"
    task linode-cli linodes disk-create $id $flags --label installer --filesystem ext4 --size $installer_size
    disk_id="$(last | awk '{print $1}')"
    installer_disk="--devices.sdb.disk_id $disk_id"
    wait_for_disk $id $disk_id

    info "Creating NIXOS disk"
    task linode-cli linodes disk-create $id $flags --label nixos --filesystem raw --size $nixos_size
    disk_id="$(last | awk '{print $1}')"
    nixos_disk="--devices.sda.disk_id $disk_id"
    wait_for_disk $id $disk_id

    # Shared flags
    flags="--text --no-header"
    flags="$flags --kernel linode/direct-disk"
    flags="$flags --helpers.updatedb_disabled=0 --helpers.distro=0 --helpers.modules_dep=0 --helpers.network=0 --helpers.devtmpfs_automount=0"

    # Create the installer configuration
    info "Creating INSTALLER configuration"
    task linode-cli linodes config-create $id $flags $nixos_disk $installer_disk --label installer --kernel linode/direct-disk --root_device /dev/sdb
    installer_config="--config_id $(last | awk '{print $1}')"
    sleep 10 && echo

    # Create the main configuration
    info "Creating NIXOS configuration"
    task linode-cli linodes config-create $id $flags $nixos_disk --label nixos --root_device /dev/sda
    nixos_config="--config_id $(last | awk '{print $1}')"
    sleep 10

    # Rescue mode
    echo && info "Rebooting the linode in RESCUE mode"
    task linode-cli linodes rescue $id $installer_disk
    sleep 5
    wait_for_linode $id "running" && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 3: Create NixOS installer            ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Create INSTALLER disk
    echo && info "Opening a Weblish console:"
    url "https://cloud.linode.com/linodes/$id/lish/weblish" && echo
    info "Paste the following to download the NixOS installer (copied to clipboard):"
    line1="iso=${iso}"; line2="curl -L \$iso | dd of=/dev/sdb"
    echo $line1
    echo $line2
    echo "$line1; $line2" | wl-copy && echo
    info "Wait until it's finished before we reboot with the INSTALLER config"
    pause

    # Installer config
    echo && info "Rebooting the linode..."
    task linode-cli linodes reboot $id $installer_config
    sleep 5
    wait_for_linode $id "running" && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 4: Install bootstrap configuration   ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    echo && info "Opening a Glish console:"
    url "https://cloud.linode.com/linodes/$id/lish/glish" && echo
    info "Paste the following to install NixOS (second line copied to clipboard):"
    local swap_flag=""; [[ "$swap" == "min" ]] || swap_flag="-s $swap"
    line1="sudo -s"
    line2="bash <(curl -sL $cli) bootstrap -h linode $swap_flag"
    echo $line1
    echo $line2
    echo "$line2" | wl-copy && echo

    info "Wait until it's finished before we reboot with NIXOS config"
    pause && echo

    # NixOS config
    info "Rebooting the linode..."
    task linode-cli linodes reboot $id $nixos_config
    sleep 5
    wait_for_linode $id "running" && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 5: Rekey secrets                     ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Wait until live and then keyscan
    local ip="$(ask_ip "$(linode-cli linodes view $id --no-header --text --format ipv4)")"
    echo && info "Waiting to keyscan the linode"
    until ping -c1 $ip >/dev/null 2>&1; do sleep 5; done
    task "nixos keyscan $ip $label --add --commit"
    echo && info "Pushing secrets back to git"
    task "cd $dir && git push"

    sleep 5 && echo

    yellow "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓"
    yellow "┃ Step 6: Switch configuration              ┃"
    yellow "┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛"

    # Switch configuration
    echo && info "Opening a Weblish console:"
    url "https://cloud.linode.com/linodes/$id/lish/weblish"
    echo && info "On the linode console, login as root. Password is also \"root\""
    show "bootstrap login: root"
    echo && info "Run the following command (copied to clipboard):"
    line1="nixos bootstrap -c $config"
    echo $line1
    echo "$line1" | wl-copy && echo

    info "After it's finished, the linode will automatically reboot into the $config configuration."
    pause && info "Install complete!"

  }

  # Stage 1 is run on NixOS installer ISO to install bootstrap configuration
  function stage1 {

    if [ "$(id -u)" != "0" ]; then
      warn "Exiting, run as root."
      return 1
    fi

    # Choose a disk to partition
    local disk part bbp esp swap butter
    if is_linode; then disk="sda"
    else
      info "Choose the disk to partition"
      disk="$(ask_disk)"
      [[ "$disk" == nvme* ]] && part="p"
    fi

    # Bail if no disk selected
    if [ ! -e /dev/$disk ]; then
      warn "Exiting, no disk selected"
      return
    fi

    # Final warning
    warn "DANGER! This script will destroy any existing data on the \"$disk\" disk."
    warn "Proceed?"
    confirm || return

    warn "OK! Proceeding in 5 seconds..."
    sleep 5 && echo && echo

    info "Create GPT partition table"
    task parted -s /dev/$disk mklabel gpt
    echo

    # Booting with legacy BIOS requires BBP and ESP partitions
    if is_bios; then

      # /dev/sda1-4
      bbp="${disk}${part}1"
      esp="${disk}${part}2"
      swap="${disk}${part}3"
      butter="${disk}${part}4"

      info "Create BIOS boot partition ($bbp)"
      task parted -s /dev/$disk mkpart BBP 1MiB 3MiB
      task parted -s /dev/$disk set 1 bios_grub on
      echo

      info "Create EFI system partition ($esp)"
      task parted -s /dev/$disk mkpart ESP FAT32 3MiB 1GiB
      task parted -s /dev/$disk set 2 esp on
      echo

      info "Create swap partition ($swap)"
      task parted -s /dev/$disk mkpart swap linux-swap 1GiB $(swap_size)GiB
      task parted -s /dev/$disk set 3 swap on
      echo

    # Booting with UEFI, the ESP partition alone is fine
    else

      # /dev/sda1-3
      esp="${disk}${part}1"
      swap="${disk}${part}2"
      butter="${disk}${part}3"

      info "Create EFI system partition ($esp)"
      task parted -s /dev/$disk mkpart ESP FAT32 1MiB 1GiB
      task parted -s /dev/$disk set 1 esp on
      echo

      info "Create swap partition ($swap)"
      task parted -s /dev/$disk mkpart swap linux-swap 1GiB $(swap_size)GiB
      task parted -s /dev/$disk set 2 swap on
      echo

    fi

    info "Create btrfs partition ($butter)"
    task parted -s /dev/$disk mkpart nix btrfs $(swap_size)GiB 100%
    echo

    info "Format EFI system partition"
    task mkfs.fat -F32 -n ESP /dev/$esp
    echo

    info "Enable swap partition"
    task mkswap /dev/$swap
    task swapon /dev/$swap
    echo

    info "Format btrfs partition"
    task mkfs.btrfs -fL nix /dev/$butter
    echo

    info "Create btrfs subvolume structure"
    # nix
    # ├── root
    # ├── snapshots
    # └── state
    #     ├── home
    #     ├── etc
    #     └── var
    #         └── log
    task mkdir -p /mnt && mount /dev/$butter /mnt
    task btrfs subvolume create /mnt/root
    task btrfs subvolume create /mnt/snapshots
    task btrfs subvolume snapshot -r /mnt/root /mnt/snapshots/root
    task btrfs subvolume create /mnt/state
    task btrfs subvolume create /mnt/state/home
    task mkdir -p /mnt/state/{var/lib,etc/{ssh,NetworkManager/system-connections}}
    task btrfs subvolume create /mnt/state/var/log
    task umount /mnt
    echo

    info "Mount root"
    task mount -o subvol=root /dev/$butter /mnt
    echo

    info "Mount nix"
    task "mkdir -p /mnt/nix && mount /dev/$butter /mnt/nix"
    echo

    info "Mount boot"
    task "mkdir -p /mnt/boot && mount /dev/$esp /mnt/boot"
    echo

    # Path to nixos flake and bootstrap configuration
    local nixos="/mnt/nix/state/etc/nixos"

    local bootstrap="$nixos/configurations/bootstrap"

    # Clone git repo into persistant directory
    info "Cloning nixos git repo"
    if [ -d $nixos ]; then
      task "cd $nixos && git pull"
    else
      task "git clone https://github.com/suderman/nixos $nixos"
    fi
    echo

    # Generate config and copy hardware-configuration.nix
    info "Generating hardware-configuration.nix"
    task nixos-generate-config --root /mnt --dir $bootstrap
    task cp -f $bootstrap/hardware-configuration.nix $nixos/
    echo

    # Modify configuration.nix based on detcted linode, uefi, or bios boot
    local cfg="$bootstrap/configuration.nix"
    info "Modifying configuration.nix with detected bootloader"
    task "sed -i '$ d' ${cfg}"
    if is_linode; then
      task "echo '  modules.linode.enable = true;' >> $cfg"
    else
      if is_bios; then
        task "echo '  boot.loader = { grub.device = \"/dev/$disk\"; grub.enable = true; };' >> $cfg"
      else
        task "echo '  boot.loader = { efi.canTouchEfiVariables = true; systemd-boot.enable = true; };' >> $cfg"
      fi
    fi
    task "echo '' >> $cfg"
    task "echo '}' >> $cfg"
    echo

    # Personal user owns /etc/nixos

    info "Updating configuration permissions"
    task chown -R 1000:100 $nixos
    echo

    # Run nixos installer
    info "Installing NixOS in 5 seconds..."
    show "nixos-install --flake $nixos\#bootstrap --no-root-password"
    sleep 5
    nixos-install --flake $nixos\#bootstrap --no-root-password
    echo

    info "Bootstrap install complete!"
    echo
    info "Reboot without installer media and login as root."
    show "bootstrap login: root"

  }

  # Stage 2 is run on bootstrap configuration, enables secrets and switches configuration
  function stage2 {
    local config="${args[--config]}"
    if has_configuration; then

      echo && info "Pulling secrets"
      task "cd $dir; git pull" && echo

      info "Copying generated hardware-configuration to $config"
      task mv -f $dir/configurations/bootstrap/hardware-configuration.nix $dir/configurations/$config/hardware-configuration.nix
      task "cd $dir; git restore configurations/bootstrap"
      task "chown -R 1000:100 $dir $dir/.git" && echo

      info "Rebuilding system to $config"
      show "nixos-rebuild switch --flake $dir\#${config}"
      nixos-rebuild switch --flake $dir\#${config}

      info "Rebuild complete!"
      info "Reboot in 10 seconds. Login as user and commit the generated hardware-configuration.nix to git."
      sleep 10 && systemctl reboot
      return 0

    else error "Exiting, missing configuration"
    fi
  }

  # Helper functions
  # ----------------

  function wait_for_linode {
    printf "  "
    while [ "$(linode-cli linodes view $1 --text --no-header --format status)" != "$2" ]; do
      echo -n $(yellow ".")
      sleep 5
    done && echo
  }

  function wait_for_disk {
    while [ "$(linode-cli linodes disk-view $1 $2 --text --no-header --format status 2>/dev/null)" != "ready" ]; do
      sleep 5
    done && echo
  }

  function configurations {
    nix flake show --json $dir | jq -r '.nixosConfigurations | keys[] | select(. != "bootstrap")' | xargs
  }

  function has_configuration {
    [[ "${args[--config]}" != "" && "${args[--config]}" != "bootstrap" ]] && return 0 || return 1
  }

  function is_linode {
    [[ "${args[--hardware]}" == "linode" ]] && return 0 || return 1
  }

  function is_bios {
    [[ "${args[--firmware]}" == "bios" || "${args[--hardware]}" == "linode" ]] && return 0 || return 1
  }

  # Total memory available in GB
  function mem_total {
    free -b | awk '/Mem/ { printf "%.0f\n", $2/1024/1024/1024 + 0.5 }'
  }

  # Total memory availble squared in GB
  function mem_squared {
    mem_total | awk '{printf("%d\n", sqrt($1)+0.5)}'
  }

  # Memory squared, minimal value 2
  function swap_min {
    local mem="$(mem_squared)"
    [ "$mem" -lt "2" ] && mem="2"
    echo $mem
  }

  # Total memory + memory squared, minimal value 2
  function swap_max {
    local mem="$(echo $(mem_total) $(mem_squared) | awk '{printf "%d", $1 + $2}')"
    [ "$mem" -lt "2" ] && mem="2"
    echo $mem
  }

  # Swap is set to second argument
  # - if min, swap is memory squared (at least 2)
  # - if max, swap is memory total + memory squared (at least 2)
  # - if empty, swap is min if linode, max otherwise
  # - if any other value, swap is set to that
  function swap_size {
    local swap="${args[--swap]}"
    if [ "$swap" = "min" ]; then
      swap="$(swap_min)"
    elif [ "$swap" = "max" ]; then
      swap="$(swap_max)"
    elif [ "$swap" = "" ]; then
      is_linode && swap="$(swap_min)" || swap="$(swap_max)"
    fi
    # Add 1 since this value will be used in parted and starts at the 1GB position
    echo $swap | awk '{printf "%d", $1 + 1}'
  }

  main

}

# :command.function
nixos_secrets_command() {
  # src/secrets_command.sh
  include awk:gawk git sed:gnused
  local dir="/etc/nixos/secrets" secret

  function main {

    # Get args and ensure agenix
    secret="${args[secret]}"
    has agenix || error "agenix missing"

    # Choose secret with menu
    secret="$(ask "[new] $(list_secrets)" $secret)"

    # If [new], ask for name of new secret
    if [[ "$secret" == "[new]" ]]; then
      secret="$(ask)"
    fi

    # Add (or use existing) secret by argument name
    has_secret "$secret" || add_secret "$secret"

    # Edit secret with agenix
    info "Editing secret with agenix"
    show "cd $dir && agenix --edit \"files/$secret.age\""
    cd $dir && agenix --edit "files/$secret.age"

    # Update files/default.nix
    write_files_nix

    # Commit secrets
    git_commit

  }

  # Write the default.nix file compiling all age files
  function write_files_nix {

    # Ouput file path

    local nix="$dir/files/default.nix"

    info "Writing $nix"

    # Build recursive attribute set
    echo "# Do not modify this file!  It was generated by ‘nixos secrets’ " > $nix
    echo "# and may be overwritten by future invocations. "                >> $nix
    echo "# Please add age files to $dir/files/*.age "                     >> $nix
    echo "{"                                                               >> $nix
    echo ""                                                                >> $nix

    # Read each encrypted age file
    for file in $dir/files/*.age; do

      # Derive the attribute key from the filename
      local name=$(basename "$file" ".age")

      # Write the attribute name and path to default.nix
      echo "  $name = ./${name}.age;" >> $nix

    done

    # Finish

    echo "" >> $nix
    echo "}" >> $nix

    show "echo \"{ ... }\" > $nix"

  }

  function list_secrets {
    local nix="$dir/secrets.nix"
    nix-instantiate --eval --expr "(import $nix)" | tr ";" "\n" | awk -F/ '{split($2, arr, "."); printf "%s ", arr[1]} END {print ""}'
  }

  function has_secret {
    [[ -z "$1" ]] && { return 1; }
    local nix="$dir/secrets.nix"
    local output="$(nix-instantiate --eval --expr "(import $nix).\"files/$1.age\"" 2>/dev/null)"
    [[ -z "$output" ]] && { return 1; }
    return 0
  }

  function add_secret {
    [[ -z "$1" ]] && { return 1; }
    local nix="$dir/secrets.nix"
    info "Appending $nix"
    task "sed -i '$ d' ${nix}"
    task "echo '  \"files/$1.age\".publicKeys = all;' >> $nix"
    task "echo '' >> $nix"
    task "echo '}' >> $nix"
  }

  function git_commit {
    info "Adding files to the staging area"
    task "cd $dir"\
         '&& git add ./secrets.nix ./files/*.age ./files/default.nix'
    if [[ "${args[--commit]}" == "1" ]]; then
      info "Committing staged files to the repository"
      task "cd $dir"\
           '&& git commit ./secrets.nix ./files/*.age ./files/default.nix'\
           "-m 'secret: $secret'"
    fi
  }

  main

}

# :command.function
nixos_rekey_command() {
  # src/rekey_command.sh
  include awk:gawk git sed:gnused
  local dir="/etc/nixos/secrets"

  function main {

    # Ensure agenix
    has agenix || error "agenix missing"

    # Update keys/default.nix
    write_keys_nix

    # Rekey secrets with agenix and restage on git
    if [[ "$(prev_hash)" != "$(calc_hash)" ]] || [[ "${args[--force]}" == "1" ]]; then
      agenix_rekey && update_hash && git_commit
    else
      info "No changes detected"
    fi

  }

  # Write the default.nix file compiling all public keys
  function write_keys_nix {

    # Ouput file path

    local nix="$dir/keys/default.nix"

    # List of all key names
    local users=""
    local systems=""

    info "Writing $nix"

    # Build recursive attribute set
    echo "$(prev_hash)" > $nix
    echo "# Do not modify this file!  It was generated by ‘nixos rekey’ "  >> $nix
    echo "# and may be overwritten by future invocations. "                >> $nix
    echo "# Please add public keys to $dir/keys/*.pub "                    >> $nix
    echo "rec {"                                                           >> $nix
    echo ""                                                                >> $nix

    # Read each @*.pub file (users) in the directory
    for file in $dir/keys/@*.pub; do

      # Derive the attribute key from the filename
      local key=$(basename "$file" ".pub")
      key="${key#@}" # remove @ from start

      # Write the attribute key and value to default.nix
      echo "  users.$key = \"$(cat "$file")\";" >> $nix

      # Collect list of key names
      users=$(echo " $users users.$key " | xargs)

    done

    # Finish with users, containing list of key names
    echo "  users.all = [ $users ];" >> $nix

    echo "" >> $nix

    # Read each *.pub file in the directory
    for file in $dir/keys/*.pub; do

      [[ "$file" =~ ^$dir/keys/@.* ]] && continue

      # Derive the attribute key from the filename
      local key=$(basename "$file" ".pub")

      # Write the attribute key and value to default.nix
      echo "  systems.$key = \"$(cat "$file")\";" >> $nix

      # Collect list of key names
      systems=$(echo " $systems systems.$key " | xargs)

    done

    # Finish with systems, containing list of key names
    echo "  systems.all = [ $systems ];" >> $nix

    echo "" >> $nix

    # Finish with all, containing list of key names
    echo "  all = users.all ++ systems.all;" >> $nix

    echo ""  >> $nix
    echo "}" >> $nix

    show "echo \"rec { ... }\" > $nix"

  }

  function prev_hash {
    head -n1 $dir/keys/default.nix
  }

  function calc_hash {
    echo "# $(ls -lah $dir/keys/*.pub | md5sum | awk '{print $1}')"
  }

  function update_hash {
    local file="$dir/keys/default.nix"
    local hash="$(calc_hash)"
    sed -i "1s/.*/$hash/" $file
  }

  # Rekey secrets with agenix
  function agenix_rekey {

    # Rekey and add any new secrets
    info "Rekeying secrets with agenix"

    show "cd $dir/secrets && agenix --rekey"
    cd $dir && agenix --rekey && return 0
    return 1

  }

  function git_commit {
    info "Adding files to the staging area"
    task "cd $dir"\
         '&& git add ./keys ./files/*.age'
    if [[ "${args[--commit]}" == "1" ]]; then
      info "Committing staged files to the repository"
      task "cd $dir"\
           '&& git commit ./keys ./files/*.age -m rekey'
    fi
  }

  main

}

# :command.function
nixos_keyscan_command() {
  # src/keyscan_command.sh
  include awk:gawk ssh-keyscan:openssh
  local dir="/etc/nixos/secrets" ip hostname

  function main {

    # Ensure ssh-keyscan
    has ssh-keyscan || error "ssh-keyscan missing"

    # Set up args
    ip="${args[ip]}" hostname="$(hostname)"

    # Attempt to scan public key
    task ssh-keyscan -t ssh-ed25519 $ip 2> /dev/null
    local key="$(last | awk '{print $2} {print $3}' | xargs)"
    local filename="$(keyfile)"

    # Check for acquired key
    show "key=\"$key\""
    if [[ -z "$key" ]]; then
      error "failed to scan key from $ip"
    fi

    # Add extra key
    if [[ "${args[--add]}" == "1" ]]; then
      filename="$(keyfile "unique")"

    # Replace existing key
    else
      # Delete any existing keys if forced
      if [[ "${args[--force]}" == "1" ]]; then
        remove "$filename"
      # Otherwise, first check if key exists
      else
        if [[ -e "$filename" ]]; then
          # Ask before deleting existing key
          info "Key \"$hostname\" already exists, replace?"

          if confirm; then
            remove "$filename"
          # Exit with error
          else
            error "Key \"$hostname\" already exists"
          fi
        fi
      fi
    fi

    show $filename

    # Write key to file
    info "Writing $filename"
    show 'echo "${key}" > '"$filename"
    echo "${key}" > $filename

    # Rekey the secrets with the new identity
    if [[ "${args[--commit]}" == "1" ]]; then
      nixos rekey --commit
    else
      nixos rekey
    fi

  }

  # Modify hostname to ensure

  # - it doesn't end in .pub
  # - periods replaces with hypens
  # - only alphanumeric with hypens and underscores
  # - no leading/trailing hypens and underscores
  # - if it starts with a number (IP address), prepend with underscore
  function hostname {
    local hostname="${args[hostname]}"
    [[ -z "$hostname" ]] && hostname="${args[ip]}"
    echo "$(awk '{

      gsub(/\.pub$/, "", $0);

      gsub(/[\. -]+/, "-", $0);

      gsub(/[^a-zA-Z0-9_-]+/, "", $0);

      gsub(/^[-_]+|[-_]+$/, "", $0);

      if (substr($0, 1, 1) ~ /^[0-9]/) { $0 = "_" $0 };

      print tolower($0)

    }' <<< $hostname)"
  }

  function keyfile {
    local filename="${dir}/keys/${hostname}.pub"
    if [[ "$1" == "unique" ]]; then
      if [[ -e $filename ]]; then

        echo "${dir}/keys/${hostname}-$(date +%s).pub"
      else
        echo "$filename"
      fi
    else
      echo "$filename"
    fi
  }

  function remove {
    info "Removing $1"
    task "rm -f $1"
  }

  main

}

# :command.function
nixos_repl_command() {
  # src/repl_command.sh
  source /etc/set-environment
  nix repl --file "/etc/nixos/repl.nix" "$@"

}

# :command.function
nixos_cache_command() {
  # src/cache_command.sh
  show "nix build .#nixosConfigurations.$(hostname).config.system.build.toplevel --json | jq -r '.[].outputs | to_entries[].value' | cachix push suderman"
  nix build .#nixosConfigurations.$(hostname).config.system.build.toplevel --json | jq -r '.[].outputs | to_entries[].value' | cachix push suderman

}

# :command.function
nixos_bashly_generate_command() {
  # src/bashly_generate_command.sh
  local dir=/etc/nixos/overlays/bin/nixos-cli
  local bashly="docker run --rm -it --user $(id -u):$(id -g) --volume $dir:/app dannyben/bashly"
  show "cd $dir && bashly generate"
  (cd $dir && $bashly generate)

}

# :command.function
nixos_completions_command() {
  # src/completions_command.sh
  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add completions
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(cli completions)"
  #
  send_completions

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        nixos_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    deploy | d)
      action="deploy"
      shift
      nixos_deploy_parse_requirements "$@"
      shift $#
      ;;

    rollback | rb)
      action="rollback"
      shift
      nixos_rollback_parse_requirements "$@"
      shift $#
      ;;

    bootstrap | b)
      action="bootstrap"
      shift
      nixos_bootstrap_parse_requirements "$@"
      shift $#
      ;;

    secrets | s)
      action="secrets"
      shift
      nixos_secrets_parse_requirements "$@"
      shift $#
      ;;

    rekey | r)
      action="rekey"
      shift
      nixos_rekey_parse_requirements "$@"
      shift $#
      ;;

    keyscan | k)
      action="keyscan"
      shift
      nixos_keyscan_parse_requirements "$@"
      shift $#
      ;;

    repl | rp)
      action="repl"
      shift
      nixos_repl_parse_requirements "$@"
      shift $#
      ;;

    cache | c)
      action="cache"
      shift
      nixos_cache_parse_requirements "$@"
      shift $#
      ;;

    bashly-generate | bg)
      action="bashly-generate"
      shift
      nixos_bashly_generate_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      nixos_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      nixos_usage >&2
      exit 1
      ;;

    *)
      if [[ -x "$(command -v "nixos-$action")" ]]; then
        shift
        exec "nixos-$action" "$@"
      else
        printf "invalid command: %s\n" "$action" >&2
        exit 1
      fi
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_deploy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_deploy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="deploy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --switch | -s)

        # :flag.case_no_arg
        args['--switch']=1
        shift
        ;;

      # :flag.case
      --boot | -b)

        # :flag.case_no_arg
        args['--boot']=1
        shift
        ;;

      # :flag.case
      --test | -t)

        # :flag.case_no_arg
        args['--test']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['target']+x} ]]; then

          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_rollback_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_rollback_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rollback"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --switch | -s)

        # :flag.case_no_arg
        args['--switch']=1
        shift
        ;;

      # :flag.case
      --boot | -b)

        # :flag.case_no_arg
        args['--boot']=1
        shift
        ;;

      # :flag.case
      --test | -t)

        # :flag.case_no_arg
        args['--test']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['target']+x} ]]; then

          args['target']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_bootstrap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help)
        long_usage=yes
        nixos_bootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c CONFIG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --hardware | -h)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--hardware']="$2"
          shift
          shift
        else
          printf "%s\n" "--hardware requires an argument: --hardware, -h HARDWARE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --firmware | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--firmware']="$2"
          shift
          shift
        else
          printf "%s\n" "--firmware requires an argument: --firmware, -f FIRMWARE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --swap | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--swap']="$2"
          shift
          shift
        else
          printf "%s\n" "--swap requires an argument: --swap, -s SWAP" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_secrets_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_secrets_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="secrets"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --commit | -c)

        # :flag.case_no_arg
        args['--commit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['secret']+x} ]]; then

          args['secret']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_rekey_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_rekey_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rekey"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --commit | -c)

        # :flag.case_no_arg
        args['--commit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_keyscan_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_keyscan_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="keyscan"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --add | -a)

        # :flag.case_no_arg
        args['--add']=1
        shift
        ;;

      # :flag.case
      --commit | -c)

        # :flag.case_no_arg
        args['--commit']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['ip']+x} ]]; then

          args['ip']=$1
          shift
        elif [[ -z ${args['hostname']+x} ]]; then

          args['hostname']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['ip']+x} ]]; then
    printf "missing required argument: IP\nusage: nixos keyscan IP [HOSTNAME] [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
nixos_repl_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_repl_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="repl"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_cache_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_cache_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="cache"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_bashly_generate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_bashly_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bashly-generate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
nixos_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        nixos_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "deploy") nixos_deploy_command ;;
    "rollback") nixos_rollback_command ;;
    "bootstrap") nixos_bootstrap_command ;;
    "secrets") nixos_secrets_command ;;
    "rekey") nixos_rekey_command ;;
    "keyscan") nixos_keyscan_command ;;
    "repl") nixos_repl_command ;;
    "cache") nixos_cache_command ;;
    "bashly-generate") nixos_bashly_generate_command ;;
    "completions") nixos_completions_command ;;
  esac
}

initialize
run "$@"
